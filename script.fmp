Go to Layout [Recurring Control Panel; Animation:undefined]
New Record/Request
Set Field [T03_Lessons::id_tutor; "T16"]
Set Field [T03_Lessons::id_student; "STUDENT1829"]
Set Field [T03_Lessons::id_subject; "499"]
Set Field [T03_Lessons::Date; Get ( CurrentDate )]
Set Field [T03_Lessons::Start_Time; "7 am"]
Set Field [T03_Lessons::End_Time; "8 am"]
Set Field [T03_Lessons::Location; "South Tampa"]
Set Field [T03_Lessons::RecurringAppointment; 1]
Set Field [T03_Lessons::RecurringDays; "TU" & ¶ &
"TH"]
Set Field [T03_Lessons::RecurringEndingChoice; "After"]
Set Field [T03_Lessons::RecurringFreq; "Week(s)"]
Set Field [T03_Lessons::RecurringInterval; 1]
Set Field [T03_Lessons::RecurringCount; 10]

Perform Script  [Specified:From list; "Calculate RRULE"; Parameter:]

Go to Layout [original layout; Animation:undefined]
# Calculates the recurrence rule for Google Calendar
# Returned Data: RRULE

# Go to Lessons_Admin
Go to Layout [T03_Lessons Admin; Animation:undefined]

# Get the required info from the record
Set Variable [$frequency; Value: Let (
  freq = T03_Lessons::RecurringFreq ;
  Case ( 
    freq = "Day(s)" ; "DAILY" ;
    freq = "Week(s)" ; "WEEKLY" ;
    freq = "Month(s)" ; "MONTHLY" ;
    freq = "Year(s)" ; "YEARLY" ;
    ""
  ) 
)]
Set Variable [$untilDate; Value: Let (
date = GetAsDate(T03_Lessons::RecurringUntil) + 1;
Year ( date ) & Right ( "00" & Month ( date ) ; 2 ) & Right ( "00" & Day ( date ) ; 2 ) & "T050000Z"
)]
Set Variable [$count; Value: T03_Lessons::RecurringCount]
Set Variable [$interval; Value: T03_Lessons::RecurringInterval]
Set Variable [$endingChoice; Value: T03_Lessons::RecurringEndingChoice]
Set Variable [$daysValueList; Value: T03_Lessons::RecurringDays]

# If any of the variables above are empty, then halt the script and display an error message. The RRule will not calculate properly unless everything is filled in. (J.Ray)
If [IsEmpty ( $frequency ) or 
IsEmpty ( $interval ) or 
IsEmpty ( $endingChoice ) or 
IsEmpty ( $daysValueList) or 

If ( $endingChoice = "Until" ; IsEmpty ( $untilDate ) ) or 
If ( $endingChoice = "Count" ; IsEmpty ( $count ) )]
  Go to Layout [original layout; Animation:undefined]
  Show Custom Dialog ["Alert!"; "At least one required piece of recurring event information is missing. Please fill in this missing information before continuing."; buttons: {["OK"; commit]}]
  Halt Script
End If

# Calculate By days
Set Variable [$numberOfDaysSelected; Value: ValueCount ( $daysValueList )]
Set Variable [$rruleDays; Value: ""]

Set Variable [$recurringDaysLoopIndex; Value: 1]
Loop
  Exit Loop If [$recurringDaysLoopIndex > $numberOfDaysSelected]
  Set Variable [$rruleDays; Value: $rruleDays & "," & GetValue ( $daysValueList ; $recurringDaysLoopIndex )]
  Set Variable [$recurringDaysLoopIndex; Value: $recurringDaysLoopIndex + 1]
End Loop
Set Variable [$byDays; Value: Right ( $rruleDays ; Length ( $rruleDays ) - 1 )]

Set Variable [$rrule; Value: Let (

  // Variables
  [
    freq = $frequency ;
    interval = $interval ;
    endingRuleName = If ( $endingChoice = "Until" ; ";UNTIL=" ; ";COUNT=" ) ;
    endingRule = If ( $endingChoice = "Until" ; $untilDate ; $count ) ;
    byDaysShow = If ( Length ( $byDays ) > 0 ; ";BYDAY=" ; "" ) ;
    byDays = If ( Length ( $byDays ) > 0 ; $byDays ; "" )
  ] ;

  // Calculation
  If ( (freq = "") or ( interval = "" ) or ( byDays = "" ) or ( endingRule = "" ) ;
    "NO RRULE" ;
    "FREQ=" & freq &
    ";INTERVAL=" & interval &
    byDaysShow & byDays &
    endingRuleName & endingRule
  )

)]
Set Field [T03_Lessons::RRULE; $rrule]

# Go back to the original layout
Go to Layout [original layout; Animation:undefined]

# return the rrule
Exit Script [$rrule]
# This script extracts info from a prepared RRULE to edit the fields in a lesson record in T03_LESSONS
# Mushfiq July 2019

# Get the rrule from the script parameter
Set Variable [$rrule; Value: Get ( ScriptParameter )]
# If no script parameter was passed, then something went wrong. halt script (JRay)
If [IsEmpty ( Get (ScriptParameter) )]
  Show Custom Dialog ["Error!"; "An error occurred while attempting to modify this recurring event. Pleast contact your database administrator to troubleshoot. Error #"  & Get (LastError); buttons: {["OK"; commit]}]
  Halt Script
End If
// Set Variable [$rrule; Value: "FREQ=WEEKLY;INTERVAL=20;BYDAY=TU,TH,FR,SA,SU;UNTIL=20190716T040000Z"]
// Set Variable [$rrule; Value: "FREQ=WEEKLY;INTERVAL=20;UNTIL=20190716T040000Z"]
// Set Variable [$rrule; Value: "FREQ=WEEKLY;INTERVAL=20;BYDAY=TU,TH;COUNT=8"]
// Set Variable [$rrule; Value: "FREQ=WEEKLY;INTERVAL=20;COUNT=8"]

# Get the Frequency and Intervals
Set Variable [$freq; Value: Let (
  [
    delimiter = ";" ;
    
    freqLabel = "FREQ=" ;
    indexOfFreq = Position ( $rrule ; freqLabel ; 1 ; 1 ) ;
    indexOfDelimiterAfterFreq = Position ( $rrule ; delimiter ; indexOfFreq ; 1 ) ;
    freqStartIndex = indexOfFreq + Length ( freqLabel ) ;
    freq = Middle ( $rrule ; freqStartIndex ; indexOfDelimiterAfterFreq - freqStartIndex )
  ] ;

  Case ( 
    freq = "WEEKLY" ; "Week(s)" ; 
    freq = "MONTHLY" ; "Month(s)" ; 
    freq = "YEARLY" ; "Year(s)" ; 
    "" 
  )
)]
Set Variable [$interval; Value: Let (
  [
    delimiter = ";" ;
    
    intervalLabel = "INTERVAL=" ;
    indexOfInterval = Position ( $rrule ; intervalLabel ; 1 ; 1 ) ;
    indexOfDelimiterAfterInterval = Position ( $rrule ; delimiter ; indexOfInterval ; 1 ) ;
    intervalStartIndex = indexOfInterval + Length ( intervalLabel ) ;
    interval = Middle ( $rrule ; intervalStartIndex ; indexOfDelimiterAfterInterval - intervalStartIndex )
  ] ;

  interval

)]

# Get the byDays value
Set Variable [$byDay; Value: Let (
  [
    delimiter = ";" ;
    
    byDayLabel = "BYDAY=" ;
    indexOfByDay = Position ( $rrule ; byDayLabel ; 1 ; 1 ) ;
    hasByDay = indexOfByDay > 0 ;
    indexOfDelimiterAfterByDay = Position ( $rrule ; delimiter ; indexOfByDay ; 1 ) ;
    byDayStartIndex = indexOfByDay + Length ( byDayLabel ) ;
    byDay = If ( hasByDay ; Middle ( $rrule ; byDayStartIndex ; indexOfDelimiterAfterByDay - byDayStartIndex ) ; "?" )
  ] ;
  byDay
)]
Set Variable [$byDayList; Value: Substitute ( $byDay ; "," ; ¶ )]
Set Variable [$byDayFullNames; Value: Substitute ( 
  Substitute ( 
    Substitute ( 
      Substitute (
        Substitute (
          Substitute (
            Substitute (
              Substitute (
                $byDay ; "SU" ; "Sundays"
              ) ; "MO" ; "Mondays"
            ) ; "TU" ; "Tuesdays"
          ) ; "WE" ; "Wednesdays"
        ) ; "TH" ; "Thursdays"    
      ) ; "FR" ; "Fridays"
    ) ; "SA" ; "Saturdays"
  ) ; "," ; ", "
)]

# Get the Until or Count 
Set Variable [$ending; Value: Let (
  
  // Variables
  [
    untilLabel = "UNTIL=" ;
    countLabel = "COUNT=" ;

    posOfUntil = Position ( $rrule ; untilLabel ; 1 ; 1 ) ; // index of "UNTIL" if it exists
    posOfCount = Position ( $rrule ; countLabel ; 1 ; 1 ) ; // index of "COUNT" if it exists

    hasUntil = posOfUntil > 0 ; // True if "UNTIL" exists
    hasCount = posOfCount > 0 ; // True if "COUNT" exists

    delimiter = ";" ;
    posOfDelimiterAfterUntil = Position ( $rrule ; delimiter ; posOfUntil ; 1 ) ;
    posOfDelimiterAfterUntil = If ( posOfDelimiterAfterUntil = 0 ; Length ( $rrule ) + 1; posOfDelimiterAfterUntil ) ;
    untilStartPos = posOfUntil + Length ( untilLabel ) ;
    untilValue = Middle ( $rrule ; untilStartPos ; posOfDelimiterAfterUntil - untilStartPos ) ;

    posOfDelimiterAfterCount = Position ( $rrule ; delimiter ; posOfCount ; 1 ) ;
    posOfDelimiterAfterCount = If ( posOfDelimiterAfterCount = 0 ; Length ( $rrule ) + 1 ; posOfDelimiterAfterCount ) ;
    countStartPos = posOfCount + Length ( countLabel ) ;
    countValue = Middle ( $rrule ; countStartPos ; posOfDelimiterAfterCount - countStartPos ) ;

    endingValue = Case ( 
      hasUntil ; untilValue ;
      hasCount ; countValue ;
      $rrule
    ) ;

    untilYear = Left ( untilValue ; 4 ) ;
    untilMonth = Middle ( untilValue ; 5 ; 2 ) ;
    untilDay = Middle ( untilValue ; 7 ; 2 ) ;
    untilDate = Date ( untilMonth ; untilDay ; untilYear )

  ] ;

  // Calculation
  JSONSetElement ( "{}" ; 
    [ "hasUntil" ; hasUntil ; JSONBoolean ] ;
    [ "untilValue" ; untilValue ; JSONString ] ;
    [ "hasCount" ; hasCount ; JSONBoolean ] ;
    [ "countValue" ; countValue ; JSONString ] ;
    [ "untilDate" ; untilDate ; JSONString ]
  )
  
)]
Set Variable [$endingChoice; Value: Let (
  [
    hasUntil = JSONGetElement ( $ending ; "hasUntil" ) ;
    hasCount = JSONGetElement ( $ending ; "hasCount" )
  ] ;
  
  Case (
    hasUntil ; "Until" ;
    hasCount ; "Count"
  )
)]
Set Variable [$endingValue; Value: Let (
  [
    untilValue = JSONGetElement ( $ending ; "untilValue" ) ;
    countValue = JSONGetElement ( $ending ; "countValue" )
  ] ;
  
  Case (
    $endingChoice = "Until" ; untilValue ;
    $endingChoice = "Count" ; countValue
  )
)]

# Pretty String output for messages
Set Variable [$recurringInfoString; Value: Let (
  [
    interval = $interval ;
    intervalNumber = If ( interval = 1 ; "" ; interval ) ;
    
    freq = $freq ;
    freqTxt = Case ( 
      freq = "Week(s)" ; "week" ;
      freq = "Month(s)" ; "month" ;
      freq = "Year(s)" ; "year" ; 
    ) ;
    freqTxt = If ( interval > 1 ; freqTxt & "s" ; freqTxt ) ;
    
    hasByDays = $byDay ≠ "?" ;
    byDaysCount = If ( hasByDays ; ValueCount ( $byDayList ) ; 0 ) ;
    byDaysTxt = If ( hasByDays ; " on " & $byDayFullNames ; "" ) ;
   
    endingChoice = $endingChoice ;
    untilDate = If ( endingChoice = "Until" ; JSONGetElement ( $ending ; "untilDate" ) ) ;
    endingTxt = Case ( 
      $endingChoice = "Count" ; "ending after " & $endingValue & " occurences." ;
      $endingChoice = "Until" ; "until " & untilDate & "."
    )

  ] ;

  "This appointment repeats every " & intervalNumber & " " & freqTxt & byDaysTxt & " " & endingTxt 

)]

Set Variable [$outputJson; Value: JSONSetElement( "{}" ;
  [ "interval" ; $interval ; JSONNumber ] ;
  [ "frequency" ; $freq ; JSONString ] ;
  [ "endingChoice" ; $endingChoice ; JSONString ] ;
  [ "endingValue" ; $endingValue ; JSONString ] ;
  [ "recurringInfoString" ; $recurringInfoString ; JSONString ]
)]
Exit Script [$outputJson]
# Create Recurring Events
# Mushfiq Mahmud May 2019

# TODO: Send Email to tutor and student
# TODO: Conflict check for the whole series

Set Error Capture [On]

// Go to Layout [Recurring Appointments; Animation:undefined]

# Get tutor ID
Set Variable [$tutorId; Value: T03_Lessons::id_tutor]

# Get lesson information
Set Variable [$studentId; Value: T03_Lessons::id_student]
Set Variable [$student; Value: T03b_lessons_STUDENTS||id_student::client_name_pk]
Set Variable [$subjectId; Value: T03_Lessons::id_subject]
Set Variable [$subject; Value: T03_lessons_SUBJECT||id_subject::Subject Name]

# Get Calendar Event information
Set Variable [$summary; Value: T03_Lessons::gcal title]
Set Variable [$description; Value: T03_Lessons::gcal description]
Set Variable [$location; Value: T03_Lessons::Location]

# Start Time
Set Variable [$startTime; Value: If ( IsEmpty ( T03_Lessons::Start_Time ) ; "" ; formatTime ( T03_Lessons::Start_Time ; "HH:MM:SS" ) )]
# End Time
Set Variable [$endTime; Value: If ( IsEmpty ( T03_Lessons::End_Time ) ; "" ; formatTime ( T03_Lessons::End_Time ; "HH:MM:SS" ) )]
# Date
Set Variable [$date; Value: 

If ( IsEmpty ( T03_Lessons::Date ) ; "" ; formatDate ( T03_Lessons::Date ; "YYYY-MM-DD" ) )]

# make sure we have the needed data to move on
If [IsEmpty ( $tutorID ) or IsEmpty ( $studentID ) or IsEmpty ( $subjectID ) or IsEmpty ( $summary ) or IsEmpty ( $location) or IsEmpty ( $startTime) or IsEmpty ( $endTime) or IsEmpty ( $date )]
  # Error log is created through a modular script done on the server.
  Perform Script on Server [Specified:From list; "Create Error Log - Modular"; Parameter:Get (ScriptName) & ¶ & 
"The recurring event could not be created because it lacked at least one of the following pieces of information: Tutor ID, Student ID, Subject ID, gcal title, Location, Date, Start Time, or End Time. Lesson #" & T03_Lessons::Lesson_IDpk; Wait for completion: Off]
  Show Custom Dialog ["Alert!"; "The recurring event could not be created because it lacked at least one of the following pieces of information: Tutor ID, Student ID, Subject ID, gcal title, Location, Start Time, or End Time."; buttons: {["OK"; commit]}]
  // Perform Script  [Specified:From list; "Create Error Log - Modular"; Parameter:Get (ScriptName) & ¶ & 
"The recurring event could not be created because it lacked at least one of the following pieces of information: Tutor ID, Student ID, Subject ID, gcal title, Location, Start Time, or End Time. Lesson #" & T03_Lessons::Lesson_IDpk]
  Halt Script
End If

# Set lesson to be non-group and tutoring
Set Field [T03_Lessons::GroupQuestion; "No"]
Set Field [T03_Lessons::Appt Category_Lessons; "Tutoring"]

# Preserve start time for late cancels by setting the startLateCancel field
Set Field [T03_Lessons::startLateCancel; T03_Lessons::Start_Time]
# Update Duration
Set Field [T03_Lessons::Duration; (T03_Lessons::End_Time - T03_Lessons::Start_Time) / 3600]

# Time Zone
Set Variable [$timeZone; Value: "America/New_York"]

Set Variable [$startDateTime; Value: $date & "T" & $startTime // startDateTime]
Set Variable [$endDateTime; Value: $date & "T" & $endTime // endDateTime]

# Calculate Recurrence Rule
Perform Script  [Specified:From list; "Calculate RRULE"; Parameter:]
Set Variable [$recurrence; Value: "RRULE:" & Get ( ScriptResult )]
If [IsEmpty ( $recurrence ) or $recurrence = "?" or $recurrence = "[]"]
  Show Custom Dialog ["Alert!"; "A problem occurred while attempting to create this recurring event. Please contact your database administrator for assistance. "; buttons: {["OK"; commit]}]
  Halt Script
End If

# Refresh the tutor's access token
Perform Script  [Specified:From list; "Refresh Access Token ( tutorId )"; Parameter:$tutorId]
Set Variable [$accessToken; Value: JSONGetElement ( Get ( ScriptResult ) ; "accessToken" )]
Set Variable [$calendarId; Value: JSONGetElement ( Get ( ScriptResult ) ; "calendarId" )]

# Calendar request data
Set Variable [$data; Value: Let ( 
  [
    startJson = JSONSetElement ( "{}" ; 
      [ "dateTime" ; $startDateTime ; JSONString ] ;
      [ "timeZone" ; $timeZone ; JSONString ] 
    ) ;
    endJson = JSONSetElement ( "{}" ; 
      [ "dateTime" ; $endDateTime ; JSONString ] ;
      [ "timeZone" ; $timeZone ; JSONString ] 
    ) 
  ] ;

  JSONSetElement ( "{}" ; 
    [ "start" ; startJson ; JSONObject ] ;
    [ "end" ; endJson ; JSONObject ] ;
    [ "summary" ; $summary ; JSONString ] ;
    [ "description" ; $description ; JSONString ] ;
    [ "location" ; $location ; JSONString ] ;
    [ "recurrence[0]" ; $recurrence ; JSONString ]
  ) 

)]

Insert from URL (WIP)
Set Variable [$eventId; Value: JSONGetElement ( $postResult ; "id")]

# Check for errors
Set Variable [$hasError; Value: Let (
  [
    errorSearchTerm = "error" ;
    list = JSONListKeys ( $postResult ; "" ) ;
    searchResult = FindValueInList ( list ; errorSearchTerm ; 1 )
  ] ;
  not (searchResult = "Not Found") or // error was returned
  Left($eventId; 1)="?" or // event ID was not in the result
  IsEmpty($eventId) // returned event ID is empty
)]
If [$hasError]
  # Show Error Message
  Show Custom Dialog ["Error in Script: " & Get ( ScriptName ); "The calendar event could not be created. The databse administrator has been notified. The following errors were logged:" & ¶ & ¶ &
JSONFormatElements ( $putResult ); buttons: {["OK"; commit]; ["Cancel"]}]
  # Send email to developers
  Send Mail (WIP)
  # Update log file
  Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:$postResult]
  Halt Script
End If

Set Field [T03_Lessons::event ID; $eventId]

# Get Recurring Instances to figure out the dates for which to create FM Lessons
Set Variable [$recurringInstancesScriptParam; Value: JSONSetElement ( "{}" ;
  [ "eventId" ; $eventId ; JSONString ] ;
  [ "calendarId" ; $calendarId ; JSONString ] ;
  [ "accessToken" ; $accessToken ; JSONString ]
)]
Perform Script  [Specified:From list; "Get Recurring Instances ( calendarId, eventId, accessToken )"; Parameter:$recurringInstancesScriptParam]
Set Variable [$datesAndInstanceIdList; Value: Get ( ScriptResult )]

# Store the original recurring event data
// Set Field [T03_Lessons::originalRecurringEventData; $data]
Set Field [T03_Lessons::originalRecurringEventData; JSONFormatElements(JSONSetElement ( "{}" ; 
  ["originalData"; $data; JSONObject];
  ["lastEndDatetime"; JSONGetElement($datesAndInstanceIdList; "lastEndDatetime"); JSONString]
))]

# Add lesson info to the JSON data
Set Variable [$datesAndInstanceIdListWithLessonInfo; Value: JSONSetElement (
  
  // Array with instances
  $datesAndInstanceIdList ;

  // Additional info
  [ "studentId" ; $studentId ; JSONString ] ;
  [ "subjectId" ; $subjectId ; JSONString ] ;
  [ "tutorId" ; $tutorId ; JSONString ] ;
  [ "summary" ; $summary ; JSONString ] ;
  [ "description" ; $description ; JSONString ] ;
  [ "location" ; $location ; JSONString ] ;
  [ "startTime" ; T03_Lessons::Start_Time ; JSONString ] ;
  [ "endTime" ; T03_Lessons::End_Time ; JSONString ] ;

  // recurring appointment series info
  [ "recurring" ; T03_Lessons::Recurring ; JSONString ] ;
  [ "recurringAppointment" ; T03_Lessons::RecurringAppointment ; JSONString ] ;
  [ "recurringDays" ; T03_Lessons::RecurringDays ; JSONString ] ;
  [ "recurringEndingChoice" ; T03_Lessons::RecurringEndingChoice ; JSONString ] ;
  [ "recurringFreq" ; T03_Lessons::RecurringFreq ; JSONString ] ;
  [ "recurringUntil" ; T03_Lessons::RecurringUntil ; JSONString ] ;
  [ "recurringCount" ; T03_Lessons::RecurringCount ; JSONNumber ] ;
  [ "recurringInterval" ; T03_Lessons::RecurringInterval ; JSONNumber ] ;
  [ "rrule" ; T03_Lessons::RRULE ; JSONString ] ;
  [ "originalData" ; $data ; JSONObject ]
)]

# Set instanceId for the first lesson
Set Field [T03_Lessons::event ID; JSONGetElement ( $datesAndInstanceIdListWithLessonInfo ; "items[0].instanceId" )]
Set Field [T03_Lessons::eventIDDump; List(T03_Lessons::eventIDDump; JSONGetElement ( $datesAndInstanceIdListWithLessonInfo ; "items[0].instanceId" ))]

# Update Log File
Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:$postResult]
Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:$datesAndInstanceIdListWithLessonInfo]

# Create FM Lessons
Perform Script  [Specified:From list; "Create Recurring Lessons in FM ( dates, instanceIds )"; Parameter:$datesAndInstanceIdListWithLessonInfo]

Go to Layout [original layout; Animation:undefined]
# This script gets the recurring series instances for an event ID in a calendar.

# Get passed in values
Set Variable [$scriptParam; Value: Get ( ScriptParameter )]
Set Variable [$calendarId; Value: JSONGetElement ( $scriptParam ; "calendarId" )]
Set Variable [$eventId; Value: JSONGetElement ( $scriptParam ; "eventId" )]
Set Variable [$accessToken; Value: JSONGetElement ( $scriptParam ; "accessToken" )]

# get Series Instances
Insert from URL (WIP)
Set Variable [$recurringEventCount; Value: ValueCount ( JSONListKeys ( $getRecurringInstancesResult ; "items") )]

# Get End Time for the last event in the series
Set Variable [$lastEndDatetime; Value: JSONGetElement ( $getRecurringInstancesResult ; "items[" & ( $recurringEventCount - 1 ) & "].end.dateTime" )]

Set Variable [$dates; Value: JSONSetElement ( "{}" ; "lastEndDatetime" ; $lastEndDatetime ; JSONString )]

# Loop through each instance
Set Variable [$recurringLoopIndex; Value: 0]
Loop
  Exit Loop If [$recurringLoopIndex ≥ $recurringEventCount]
  
  # Get the instance ID
  Set Variable [$instanceId; Value: JSONGetElement ( $getRecurringInstancesResult ; "items[" & $recurringLoopIndex & "].id" )]
  
  # extract the start date for that instance
  Set Variable [$extractedDate; Value: JSONGetElement ( $getRecurringInstancesResult ; "items[" & $recurringLoopIndex & "].start.dateTime" )]
  Set Variable [$formattedDate; Value: Let ( 

  // Variables
  [ 
    year = Left ( $extractedDate ; 4 ) ;
    month = Middle ( $extractedDate ; 6 ; 2 );
    day = Middle ( $extractedDate ; 9 ; 2 ) ;

    time = Middle ( $extractedDate ; Position ( $extractedDate ; "T" ; 1 ; 1 ) + 1 ; 8 ) ;
    
    formattedDate = month & "/" & day & "/" & year ;
    formattedDateTime = month & "/" & day & "/" & year & " " & time

  ] ; 
  
  // Calculation
  formattedDateTime
  
)]
  
  # Calculate DST Offset for that date
  // Perform Script  [Specified:From list; "Calculate DST Offset ( timestamp )"; Parameter:$formattedDate]
  Set Variable [$dstOffset; Value: FindDSTOffset ( GetAsTimestamp ( $formattedDate ) )]
  Set Variable [$formattedTimestamp; Value: Let ( 

  // Variables
  [ 
    timestamp = GetAsTimestamp ( $formattedDate ) ;
    offsetedtimestamp = timestamp + $dstOffset * 60 * 60

    // year = Left ( $extractedDate ; 4 ) ;
    // month = Middle ( $extractedDate ; 6 ; 2 );
    // day = Middle ( $extractedDate ; 9 ; 2 ) ;

    // time = Middle ( $extractedDate ; Position ( $extractedDate ; "T" ; 1 ; 1 ) + 1 ; 8 ) ;
    
    // formattedDate = month & "/" & day & "/" & year ;
    // formattedDateTime = month & "/" & day & "/" & year & " " & time

  ] ; 
  
  // Calculation
  offsetedtimestamp 
  
)]
  
  # Create list of dates as the loop continues
  Set Variable [$dates; Value: Let (

  // Variables
  insideJson = JSONSetElement (
    "{}" ;
    [ "date" ; GetAsDate ( $formattedTimestamp ) ; JSONString ] ;
    [ "instanceId" ; $instanceId ; JSONString ]
  ) ;

  // Calculation
  JSONSetElement ( $dates ; "items[" & $recurringLoopIndex & "]" ; insideJson ; JSONObject )

)]
  
  Set Variable [$recurringLoopIndex; Value: $recurringLoopIndex + 1]
End Loop

# Return the list of dates
Exit Script [$dates]
# This script accepts a list of dates in which to create a recurring lesson record series.

Set Error Capture [On]

# Script Parameter containing all info
Set Variable [$json; Value: Get ( ScriptParameter )]

# Count of instances
Set Variable [$instanceCount; Value: ValueCount ( JSONListKeys ( $json ; "items" ) )]

# Start from the second item since the first one will already be created in FM
Set Variable [$loopIndex; Value: 1]
Loop
  Exit Loop If [$loopIndex ≥ $instanceCount]
  
  # Get Date and instanceId for the lesson
  Set Variable [$date; Value: JSONGetElement ( $json ; "items[" & $loopIndex & "].date" )]
  Set Variable [$instanceId; Value: JSONGetElement ( $json ; "items[" & $loopIndex & "].instanceId" )]
  
  # Create new records in the Lessons Table
  Go to Layout [T03_Lessons Admin; Animation:undefined]
  Show All Records
  New Record/Request
  
  # Put everything in the right place
  Set Field [T03_Lessons::id_student; JSONGetElement ( $json ; "studentId" )]
  Set Field [T03_Lessons::id_subject; JSONGetElement ( $json ; "subjectId" )]
  Set Field [T03_Lessons::id_tutor; JSONGetElement ( $json ; "tutorId" )]
  Set Field [T03_Lessons::Location; JSONGetElement ( $json ; "location" )]
  
  Set Field [T03_Lessons::Start_Time; JSONGetElement ( $json ; "startTime" )]
  Set Field [T03_Lessons::startLateCancel; T03_Lessons::Start_Time]
  Set Field [T03_Lessons::End_Time; JSONGetElement ( $json ; "endTime" )]
  Set Field [T03_Lessons::Date; $date]
  Set Field [T03_Lessons::Duration; (T03_Lessons::End_Time - T03_Lessons::Start_Time) / 3600]
  
  Set Field [T03_Lessons::originalRecurringEventData; Let (
  [
    originalData = JSONGetElement ( $json ; "originalData" ) ;
    lastEndDatetime = JSONGetElement ( $json ; "lastEndDatetime" )
  ] ;
  
  JSONFormatElements(JSONSetElement ( "{}" ; 
    [ "originalData" ; originalData ; JSONObject ] ;
    [ "lastEndDatetime" ; lastEndDatetime ; JSONString ]
  ))

)]
  
  Set Field [T03_Lessons::event ID; $instanceId]
  Set Field [T03_Lessons::GroupQuestion; "No"]
  Set Field [T03_Lessons::Appt Category_Lessons; "Tutoring"]
  
  Set Field [T03_Lessons::Recurring; JSONGetElement( $json ; "recurring" )]
  Set Field [T03_Lessons::RecurringAppointment; JSONGetElement( $json ; "recurringAppointment" )]
  Set Field [T03_Lessons::RecurringDays; JSONGetElement( $json ; "recurringDays" )]
  Set Field [T03_Lessons::RecurringEndingChoice; JSONGetElement( $json ; "recurringEndingChoice" )]
  Set Field [T03_Lessons::RecurringFreq; JSONGetElement( $json ; "recurringFreq" )]
  Set Field [T03_Lessons::RecurringUntil; JSONGetElement( $json ; "recurringUntil" )]
  Set Field [T03_Lessons::RecurringCount; JSONGetElement( $json ; "recurringCount" )]
  Set Field [T03_Lessons::RecurringInterval; JSONGetElement( $json ; "recurringInterval" )]
  Set Field [T03_Lessons::RRULE; JSONGetElement( $json ; "rrule" )]
  
  Set Field [T03_Lessons::eventIDDump; List(T03_Lessons::eventIDDump; $instanceId)]
  
  // Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:JSONGetElement($json; "originalPostResult")]
  Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:$json]
  
  # Commit Records
  Commit Records/Requests [With dialog:Off]
  
  Set Variable [$loopIndex; Value: $loopIndex + 1]
End Loop

# Perform find for the new series
Enter Find Mode [Pause:Off]
Set Field [T03_Lessons::event ID; Let (
  // Get the event ID from the beginning part of any of the instance IDs
  instanceId = JSONGetElement ( $json ; "items[0].instanceId" ) ; 
  Left ( instanceId ; Position ( instanceId ; "_" ; 1 ; 1 ) - 1 )
)]
Perform Find []

# Send Email
Perform Script  [Specified:From list; "Calculate recurring options from RRULE ( rrule )"; Parameter:JSONGetElement ( $json ; "rrule" )]
Set Variable [$recurringInfoString; Value: JSONGetElement ( Get ( ScriptResult ) ; "recurringInfoString" )]

Go to Layout [original layout; Animation:undefined]
Show Custom Dialog ["Send Email?"; "Notify student and tutor with email?"; buttons: {["Yes"]; ["No"]}]
If [Get(LastMessageChoice) = 1]
  Set Variable [$To; Value: formatEmailList( List( 
  T03b_lessons_STUDENTS||id_student::Student_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent1_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent2_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent3_EmailAddress_Students 
))]
  Set Variable [$CC; Value: T03j_lessons_TUTOR||id_tutor::Tutor_Company_EmailAddress]
  Send Mail (WIP)
End If

Go to Layout [original layout; Animation:undefined]
# This script edits all occurences of a series in Google Calendar
# Mushfiq July 2019

// Go to Layout [Recurring Appointments; Animation:undefined]
Set Error Capture [On]
Allow User Abort (WIP)

# Get the event ID
Set Variable [$eventId; Value: Let (
  indexAfterEventId = Position ( T03_Lessons::event ID ; "_" ; 1 ; 1 ) ;
  Left ( T03_Lessons::event ID ; indexAfterEventId - 1 )
)]

# Get the event details
Set Variable [$studentId; Value: T03_Lessons::id_student]
Set Variable [$subjectId; Value: T03_Lessons::id_subject]
Set Variable [$tutorId; Value: T03_Lessons::id_tutor]

# Get Calendar Event information
Set Variable [$summary; Value: T03_Lessons::gcal title]
Set Variable [$description; Value: T03_Lessons::gcal description]
Set Variable [$location; Value: T03_Lessons::Location]

# If any of the variables above (and a couple others) are empty, then halt the script and display an error message. The rest of the script will not run properly without these variables being filled in. (J.Ray)
If [IsEmpty ( $eventId) or 
Left($eventId; 1)="?" or // invalid event ID
IsEmpty ( $studentId ) or 
IsEmpty ( $subjectId ) or 
IsEmpty ( $tutorId ) or 
IsEmpty ( $location ) or 
IsEmpty ( T03_Lessons::Start_Time ) or 
IsEmpty ( T03_Lessons::End_Time ) or 
IsEmpty ( T03_Lessons::Date )]
  Go to Layout [original layout; Animation:undefined]
  Show Custom Dialog ["Alert!"; "All of the following must be filled in before continuing: Student ID, Subject ID, Tutor ID, Date, Start Time, End Time, Location, Google Event ID, Google Event Description, and Google Event Summary."; buttons: {["OK"; commit]}]
  Halt Script
End If

# Start Time
# -- this variable now uses a custom function instead of a subscript. (J. Ray)
Set Variable [$startTime; Value: formatTime ( T03_Lessons::Start_Time ; "HH:MM:SS" )]
# End Time
# -- this variable now uses a custom function instead of a subscript. (J. Ray)
Set Variable [$endTime; Value: formatTime ( T03_Lessons::End_Time ; "HH:MM:SS" )]

# Date
# -- this variable now uses a custom function instead of a subscript. (J. Ray)
Set Variable [$date; Value: formatDate ( T03_Lessons::Date ; "YYYY-MM-DD" )]
Set Variable [$startDateTime; Value: $date & "T" & $startTime // startDateTime]
Set Variable [$endDateTime; Value: $date & "T" & $endTime // endDateTime]

# Update Duration
# -- validation check --> The start time must be less than the end time.
If [T03_Lessons::Start_Time >= T03_Lessons::End_Time]
  Show Custom Dialog ["Alert!"; "The start time must be less than the end time. Please correct this before continuing."; buttons: {["OK"; commit]}]
  Halt Script
End If
Set Field [T03_Lessons::Duration; (T03_Lessons::End_Time - T03_Lessons::Start_Time) / 3600]

# RRULE recalculation
Perform Script  [Specified:From list; "Calculate RRULE"; Parameter:]
Set Variable [$rrule; Value: "RRULE:" & Get ( ScriptResult )]

# VALIDATION CHECK
# if the returned RRule from the subscript is empty, then log an error using the modular error script below and halt. (J.Ray)
If [IsEmpty ( $rrule )]
  Perform Script on Server [Specified:From list; "Create Error Log - Modular"; Parameter:Get (ScriptName) & ¶ & 
"RRULE could not be created for Lesson #" & T03_Lessons::Lesson_IDpk & ". Empty RRule result was returned from the 'Create RRule' subscript."; Wait for completion: Off]
  Show Custom Dialog ["Alert!"; "A problem occurred attempting to modify this recurring event. Please contact your database administrator."; buttons: {["OK"; commit]}]
  Halt Script
End If

Set Variable [$json; Value: JSONSetElement ( "{}" ;
  [ "recurring" ; T03_Lessons::Recurring ; JSONString ] ;
  [ "recurringAppointment" ; T03_Lessons::RecurringAppointment ; JSONString ] ;
  [ "recurringDays" ; T03_Lessons::RecurringDays ; JSONString ] ;
  [ "recurringEndingChoice" ; T03_Lessons::RecurringEndingChoice ; JSONString ] ;
  [ "recurringFreq" ; T03_Lessons::RecurringFreq ; JSONString ] ;
  [ "recurringUntil" ; T03_Lessons::RecurringUntil ; JSONString ] ;
  [ "recurringCount" ; T03_Lessons::RecurringCount ; JSONNumber ] ;
  [ "recurringInterval" ; T03_Lessons::RecurringInterval ; JSONNumber ] ;
  [ "rrule" ; T03_Lessons::RRULE ; JSONString ]
)]
# VALIDATION CHECK
# if a problem was found in the json, then log an error using the modular error script below and halt. (J.Ray)
If [Left ( JSONFormatElements ( $json ) ; 1 ) = "?"]
  Perform Script on Server [Specified:From list; "Create Error Log - Modular"; Parameter:Get (ScriptName) & ¶ & 
"RRULE could not be created for Lesson #" & T03_Lessons::Lesson_IDpk & ". JSON syntax error attempting to create the new RRule in the 'json' variable."; Wait for completion: Off]
  Show Custom Dialog ["Alert!"; "A problem occurred attempting to modify this recurring event. Please contact your database administrator."; buttons: {["OK"; commit]}]
  Halt Script
End If

# Time Zone
Set Variable [$timeZone; Value: "America/New_York"]

# VALIDATION CHECK
# if a problem was found in the json, then log an error using the modular error script below and halt. (J.Ray)
Set Variable [$data; Value: Let ( 
  [
    startJson = JSONSetElement ( "{}" ; 
      [ "dateTime" ; $startDateTime ; JSONString ] ;
      [ "timeZone" ; $timeZone ; JSONString ] 
    ) ;
    endJson = JSONSetElement ( "{}" ; 
      [ "dateTime" ; $endDateTime ; JSONString ] ;
      [ "timeZone" ; $timeZone ; JSONString ] 
    ) 
  ] ;

  JSONSetElement ( "{}" ; 
    [ "start" ; startJson ; JSONObject ] ;
    [ "end" ; endJson ; JSONObject ] ;
    [ "summary" ; $summary ; JSONString ] ;
    [ "description" ; $description ; JSONString ] ;
    [ "location" ; $location ; JSONString ] ;
    [ "recurrence[0]" ; $rrule ; JSONString ]
  ) 

)]
If [Left ( JSONFormatElements ( $data) ; 1 ) = "?"]
  Perform Script on Server [Specified:From list; "Create Error Log - Modular"; Parameter:Get (ScriptName) & ¶ & 
"RRULE could not be created for Lesson #" & T03_Lessons::Lesson_IDpk & ". JSON syntax error attempting to create the new RRule in the 'data' variable."; Wait for completion: Off]
  Show Custom Dialog ["Alert!"; "A problem occurred attempting to modify this recurring event. Please contact your database administrator."; buttons: {["OK"; commit]}]
  Halt Script
End If

# Refresh the tutor's access token
Perform Script  [Specified:From list; "Refresh Access Token ( tutorId )"; Parameter:$tutorId]
Set Variable [$accessToken; Value: JSONGetElement ( Get ( ScriptResult ) ; "accessToken" )]
Set Variable [$calendarId; Value: JSONGetElement ( Get ( ScriptResult ) ; "calendarId" )]
# if the access token or calendar id was not returned correctly from Google, then send an error message to the developer, display error message, and halt script (J.Ray)
If [IsEmpty ( $accessToken ) or IsEmpty ( $calendarId )]
  Perform Script on Server [Specified:From list; "Create Error Log - Modular"; Parameter:Get (ScriptName) & ¶ & 
"RRULE could not be created for Lesson #" & T03_Lessons::Lesson_IDpk & ". Access Token or Calendar ID could not be not be retrieved from the Google API."; Wait for completion: Off]
  Show Custom Dialog ["Alert!"; "A problem occurred attempting to modify this recurring event. Please contact your database administrator."; buttons: {["OK"; commit]}]
  Halt Script
End If

# PUT event to change series
Insert from URL (WIP)

# Check for errors
Set Variable [$hasError; Value: Let (
  [
    errorSearchTerm = "error" ;
    list = JSONListKeys ( $putResult ; "" ) ;
    searchResult = FindValueInList ( list ; errorSearchTerm ; 1 )
  ] ;
  not (searchResult = "Not Found") or // error was returned
  Left($eventId; 1)="?" or // event ID was not in the result
  IsEmpty($eventId) // returned event ID is empty
)]
If [$hasError]
  # Send email to developers
  Perform Script on Server [Specified:From list; "Create Error Log - Modular"; Parameter:Get (ScriptName) & ¶ &
"The following errors were logged:" & ¶ & ¶ &
JSONFormatElements ( $putResult ) & ¶ & ¶ &

"Lesson Details:" & ¶ &
"Lesson ID: " & T03_Lessons::Lesson_IDpk & ¶ &
"Student: " & T03b_lessons_STUDENTS||id_student::client_name_pk & " (" & T03_Lessons::id_student & ")" & ¶ &
"Subject: " & T03_lessons_SUBJECT||id_subject::Subject Name & " (" & T03_Lessons::id_subject & ")" & ¶ &
"Tutor: " & T03j_lessons_TUTOR||id_tutor::TutorName_TutorInfo & " (" & T03_Lessons::id_tutor & ")" & ¶ &
"Location: " & T03_Lessons::Location & ¶ &
"Date: " & T03_Lessons::Date & ¶ &
"Start: " & T03_Lessons::Start_Time & ¶ &
"End: " & T03_Lessons::End_Time; Wait for completion: Off]
  # Update log file
  Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:$postResult]
  Show Custom Dialog ["Alert!"; "A problem occurred attempting to modify this recurring event. Please contact your database administrator."; buttons: {["OK"; commit]}]
  Halt Script
End If

# Update Log File
Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:$putResult]


# Search for the event ID that is shared across all the instances
Enter Find Mode [Pause:Off]
Set Field [T03_Lessons::event ID; "=" & $eventId]
Perform Find []
If [Get (LastError)]
  Perform Script on Server [Specified:From list; "Create Error Log - Modular"; Parameter:Get (ScriptName) & ¶ & 
"Problem finding the event ID for Lesson #" & T03_Lessons::Lesson_IDpk & "."; Wait for completion: Off]
  Show Custom Dialog ["Alert!"; "A problem occurred attempting to modify this recurring event. Please contact your database administrator."; buttons: {["OK"; commit]}]
  Halt Script
End If
Go to Record/Request/Page [First]

# Get count of events in series
Set Variable [$foundCount; Value: Get ( FoundCount )]

# Delete the series
Delete All Records [With dialog:Off]

Perform Script  [Specified:From list; "Get Recurring Instances ( calendarId, eventId, accessToken )"; Parameter:JSONSetElement ( "{}" ; 
  [ "calendarId" ; $calendarId ; JSONString ] ;
  [ "eventId" ; $eventId ; JSONString ] ;
  [ "accessToken" ; $accessToken ; JSONString ]
)]
Set Variable [$datesAndInstanceIdList; Value: Get ( ScriptResult )]
Set Variable [$instanceCount; Value: ValueCount ( JSONListKeys ( $datesAndInstanceIdList ; "items" ) )]
# if the new recurring event dates were not retrieved from Google, then send an error message to the developer, display error message, and halt script (J.Ray)
If [IsEmpty ( $datesAndInstanceIdList) or IsEmpty ( $instanceCount)]
  Perform Script on Server [Specified:From list; "Create Error Log - Modular"; Parameter:Get (ScriptName) & ¶ & 
"Problem retrieving the recurring event list from Google for Lesson #" & T03_Lessons::Lesson_IDpk & "."; Wait for completion: Off]
  Show Custom Dialog ["Alert!"; "A problem occurred attempting to retrieve the new recurring event list from Google. Please contact your database administrator."; buttons: {["OK"; commit]}]
  Halt Script
End If

# Loop through each record and update the info
Set Variable [$loopIndex; Value: 0]
Loop
  Exit Loop If [$loopIndex ≥ $instanceCount]
  
  # Create a new record
  New Record/Request
  Set Field [T03_Lessons::id_student; $studentId]
  Set Field [T03_Lessons::id_subject; $subjectId]
  Set Field [T03_Lessons::id_tutor; $tutorId]
  
  Set Field [T03_Lessons::Start_Time; $startTime]
  Set Field [T03_Lessons::End_Time; $endTime]
  Set Field [T03_Lessons::Duration; (T03_Lessons::End_Time - T03_Lessons::Start_Time) / 3600]
  
  Set Field [T03_Lessons::Date; JSONGetElement ( $datesAndInstanceIdList ; "items[" & $loopIndex & "].date" )]
  Set Field [T03_Lessons::event ID; JSONGetElement ( $datesAndInstanceIdList ; "items[" & $loopIndex & "].instanceId" )]
  
  Set Field [T03_Lessons::Location; $location]
  
  Set Field [T03_Lessons::Recurring; JSONGetElement( $json ; "recurring" )]
  Set Field [T03_Lessons::RecurringAppointment; JSONGetElement( $json ; "recurringAppointment" )]
  Set Field [T03_Lessons::RecurringDays; JSONGetElement( $json ; "recurringDays" )]
  Set Field [T03_Lessons::RecurringEndingChoice; JSONGetElement( $json ; "recurringEndingChoice" )]
  Set Field [T03_Lessons::RecurringFreq; JSONGetElement( $json ; "recurringFreq" )]
  Set Field [T03_Lessons::RecurringUntil; JSONGetElement( $json ; "recurringUntil" )]
  Set Field [T03_Lessons::RecurringCount; JSONGetElement( $json ; "recurringCount" )]
  Set Field [T03_Lessons::RecurringInterval; JSONGetElement( $json ; "recurringInterval" )]
  Set Field [T03_Lessons::RRULE; JSONGetElement( $json ; "rrule" )]
  
  Set Variable [$loopIndex; Value: $loopIndex + 1]
End Loop
Commit Records/Requests [With dialog:Off]

# Send Email
Perform Script  [Specified:From list; "Calculate recurring options from RRULE ( rrule )"; Parameter:JSONGetElement ( $json ; "rrule" )]
Set Variable [$recurringInfoString; Value: JSONGetElement ( Get ( ScriptResult ) ; "recurringInfoString" )]

Go to Layout [T03_Lessons Admin; Animation:undefined]
Show Custom Dialog ["Send Email?"; "Notify student and tutor with email?"; buttons: {["Yes"]; ["No"]}]
If [Get(LastMessageChoice) = 1]
  Set Variable [$To; Value: formatEmailList( List( 
  T03b_lessons_STUDENTS||id_student::Student_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent1_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent2_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent3_EmailAddress_Students 
))]
  Set Variable [$CC; Value: T03j_lessons_TUTOR||id_tutor::Tutor_Company_EmailAddress]
  Send Mail (WIP)
End If

# Perform find for this event ID
Enter Find Mode [Pause:Off]
Set Field [T03_Lessons::event ID; "=" & $eventId]
Perform Find []

Go to Layout [original layout; Animation:undefined]
# This script will delete a recurring series in its entirety. Both in Google Calendar and in FM
# Mushfiq July 2019

Set Error Capture [On]

# Get the event ID
Set Variable [$eventId; Value: Let (
  indexAfterEventId = Position ( T03_Lessons::event ID ; "_" ; 1 ; 1 ) ;
  Left ( T03_Lessons::event ID ; indexAfterEventId - 1 )
)]
Set Variable [$instanceId; Value: T03_Lessons::event ID]
If [Left($eventId; 1)="?" or // invalid event ID
IsEmpty($eventId) // empty event ID]
  Show Custom Dialog ["Missing Event ID"; "This lesson series cannot be deleted due to a missing event ID. Please contact your database administrator."; buttons: {["OK"; commit]}]
  Halt Script
End If

# Refresh Access Token
Set Variable [$tutorId; Value: T03_Lessons::id_tutor]
Perform Script  [Specified:From list; "Refresh Access Token ( tutorId )"; Parameter:$tutorId]
Set Variable [$accessToken; Value: JSONGetElement ( Get ( ScriptResult ) ; "accessToken" )]
Set Variable [$calendarId; Value: JSONGetElement ( Get ( ScriptResult ) ; "calendarId" )]

# Find all lessons with the same event ID
// Go to Layout [Recurring Appointments; Animation:undefined]
Enter Find Mode [Pause:Off]
Set Field [T03_Lessons::event ID; "=" & $eventId]
Perform Find []
# If no lessons found, then stop script (JRay)
If [Get (LastError)]
  Show Custom Dialog ["Error"; "An error occurred while attempting to delete this recurring event. The recurring event could not be deleted. Please contact your database administrator to troubleshoot."; buttons: {["OK"; commit]}]
  Halt Script
End If

# Delete each lesson
Set Variable [$foundLessons; Value: Get ( FoundCount )]

Show Custom Dialog [Let (
  isSingular = If ( $foundLessons = 1 ; True ; False ) ;
  "Delete " & $foundLessons & " " & If ( isSingular ; "lesson" ; "lessons") & "?"
); Let (
  isSingular = If ( $foundLessons = 1 ; True ; False ) ;
  $foundLessons & " " & If ( isSingular ; "lesson" ; "lessons") & " found. Delete?"
); buttons: {["OK"; commit]; ["Cancel"]}]
If [Get ( LastMessageChoice ) = 2]
  Halt Script
End If

# Send Email
Perform Script  [Specified:From list; "Calculate recurring options from RRULE ( rrule )"; Parameter:JSONGetElement ( $json ; "rrule" )]
Set Variable [$recurringInfoString; Value: JSONGetElement ( Get ( ScriptResult ) ; "recurringInfoString" )]

Go to Layout [T03_Lessons Admin; Animation:undefined]
Show Custom Dialog ["Send Email?"; "Notify student and tutor with email?"; buttons: {["Yes"]; ["No"]}]
If [Get(LastMessageChoice) = 1]
  Set Variable [$To; Value: formatEmailList( List( 
  T03b_lessons_STUDENTS||id_student::Student_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent1_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent2_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent3_EmailAddress_Students 
))]
  Set Variable [$CC; Value: T03j_lessons_TUTOR||id_tutor::Tutor_Company_EmailAddress]
  Send Mail (WIP)
End If

# Delete from Google Calendar
Insert from URL (WIP)
# Traps for errors after attempting to insert from URL (JRay)
# Using simply "Get (LastError)" means that if Get (LastError) retunred anything but null or 0, then somethign went wrong, and the script should stop.
If [Get (LastError)]
  Show Custom Dialog ["Calendar"; "An error occurred. This recurring event could not be deleted on Google Calendar. Please contact your database administrator to troubleshoot. Error #" & Get (LastError); buttons: {["OK"; commit]}]
  Halt Script
End If


Set Variable [$loopIndex; Value: 1]
Loop
  Exit Loop If [$loopIndex > $foundLessons]
  
  Set Variable [$jsonLessonData; Value: JSONSetElement ( "{}" ;
  [ "date" ; T03_Lessons::Date; JSONString ] ;
  [ "lessonId" ; T03_Lessons::Lesson_IDpk; JSONString ] ;
  [ "start" ; T03_Lessons::Start_Time; JSONString ] ;
  [ "end" ; T03_Lessons::End_Time; JSONString ] ;
  [ "timeOfCancel" ; T03_Lessons::Time_Cancel_Lessons; JSONString ] ;
  [ "attended" ; T03_Lessons::Attendance; JSONString ] ;
  [ "familyId" ; T03_Lessons::id_family; JSONString ] ;
  [ "studentId" ; T03_Lessons::id_student; JSONString ] ;
  [ "studentName" ; T03b_lessons_STUDENTS||id_student::client_name_pk; JSONString ] ;
  [ "subjectId" ; T03_Lessons::id_subject; JSONString ] ;
  [ "tutorId" ; T03_Lessons::id_tutor; JSONString ] ;
  [ "billingNotes" ; T03_Lessons::Notes_Billing_Cancellations_Lessons; JSONString ] ;
  [ "location" ; T03_Lessons::Location; JSONString ] ;
  [ "hiddenHttpResult" ; T03_Lessons::logFile ; JSONString ]
)]
  
  # Put all information in the cancelled table
  Go to Layout [Canceled Lessons; Animation:undefined]
  New Record/Request
  Set Field [Canceled Lessons::id_lesson; JSONGetElement ( $jsonLessonData ; "lessonId")]
  Set Field [Canceled Lessons::Date; JSONGetElement ( $jsonLessonData ; "date")]
  Set Field [Canceled Lessons::Attendance; JSONGetElement ( $jsonLessonData ; "attended")]
  Set Field [Canceled Lessons::id_family; JSONGetElement ( $jsonLessonData ; "familyId")]
  Set Field [Canceled Lessons::id_student; JSONGetElement ( $jsonLessonData ; "studentId")]
  Set Field [Canceled Lessons::id_subject; JSONGetElement ( $jsonLessonData ; "subjectId")]
  Set Field [Canceled Lessons::id_tutor; JSONGetElement ( $jsonLessonData ; "tutorId")]
  Set Field [Canceled Lessons::NotesCancel; JSONGetElement ( $jsonLessonData ; "billingNotes")]
  Set Field [Canceled Lessons::start; JSONGetElement ( $jsonLessonData ; "start")]
  Set Field [Canceled Lessons::TimeCancel; JSONGetElement ( $jsonLessonData ; "timeOfCancel")]
  Set Field [Canceled Lessons::end; JSONGetElement ( $jsonLessonData ; "end")]
  Set Field [Canceled Lessons::location; JSONGetElement ( $jsonLessonData ; "location")]
  Set Field [Canceled Lessons::event ID; $instanceId]
  
  Set Field [Canceled Lessons::log; $deleteResult & ¶ & ¶ & 

JSONGetElement ( $jsonLessonData ; "hiddenHttpResult" )]
  
  Go to Layout [T03_Lessons Admin; Animation:undefined]
  Delete Record/Request [With dialog:Off]
  
  Set Variable [$loopIndex; Value: $loopIndex + 1]
End Loop


Go to Layout [original layout; Animation:undefined]
# Edit an instance of a recurring series on Google Calendar
# Mushfiq Mahmud Jun 2019

# Make sure to go to T03_Lessons in case it is not initiated from there
Go to Layout [T03_Lessons; Animation:undefined]

# Get instance ID
Set Variable [$instanceId; Value: T03_Lessons::event ID]

# Check if indeed an instance of a recurring series or not
If [Position ( $instanceId ; "_" ; 1 ; 1 ) = 0]
  Show Custom Dialog ["Not a Recurring Series."; "The script that ran this assumed this was a recurring series instance. Please follow normal protocol to edit a single event."; buttons: {["OK"; commit]; ["Cancel"]}]
  Halt Script
End If

# Get tutor ID
Set Variable [$tutorId; Value: T03_Lessons::id_tutor]

# Get lesson information
Set Variable [$studentId; Value: T03_Lessons::id_student]
Set Variable [$student; Value: T03b_lessons_STUDENTS||id_student::client_name_pk]
Set Variable [$subjectId; Value: T03_Lessons::id_subject]
Set Variable [$subject; Value: T03_lessons_SUBJECT||id_subject::Subject Name]

# Get Calendar Event information
Set Variable [$summary; Value: T03_Lessons::gcal title]
Set Variable [$description; Value: T03_Lessons::gcal description]
Set Variable [$location; Value: T03_Lessons::Location]

# Start Time
Set Variable [$startTime; Value: T03_Lessons::Start_Time]
Perform Script  [Specified:From list; "Convert Time to HH:MM:SS ( time )"; Parameter:$startTime]
Set Variable [$startTime; Value: Get ( ScriptResult )]
# End Time
Set Variable [$endTime; Value: T03_Lessons::End_Time]
Perform Script  [Specified:From list; "Convert Time to HH:MM:SS ( time )"; Parameter:$endTime]
Set Variable [$endTime; Value: Get ( ScriptResult )]
# Update Duration
Set Field [T03_Lessons::Duration; (T03_Lessons::End_Time - T03_Lessons::Start_Time) / 3600]

# Time Zone
Set Variable [$timeZone; Value: "America/New_York"]

# Date
Set Variable [$date; Value: T03_Lessons::Date]
Perform Script  [Specified:From list; "Convert date to YYYY-MM-DD ( date )"; Parameter:$date]
Set Variable [$date; Value: JSONGetElement ( Get ( ScriptResult ) ; "date" )]
Set Variable [$startDateTime; Value: $date & "T" & $startTime // startDateTime]
Set Variable [$endDateTime; Value: $date & "T" & $endTime // endDateTime]

# Refresh the tutor's access token
Perform Script  [Specified:From list; "Refresh Access Token ( tutorId )"; Parameter:$tutorId]
Set Variable [$accessToken; Value: JSONGetElement ( Get ( ScriptResult ) ; "accessToken" )]
Set Variable [$calendarId; Value: JSONGetElement ( Get ( ScriptResult ) ; "calendarId" )]

# PUT Body
Set Variable [$data; Value: Let ( 
  [
    startJson = JSONSetElement ( "{}" ; 
      [ "dateTime" ; $startDateTime ; JSONString ] ;
      [ "timeZone" ; $timeZone ; JSONString ] 
    ) ;
    endJson = JSONSetElement ( "{}" ; 
      [ "dateTime" ; $endDateTime ; JSONString ] ;
      [ "timeZone" ; $timeZone ; JSONString ] 
    ) 
  ] ;

  JSONSetElement ( "{}" ; 
    [ "start" ; startJson ; JSONObject ] ;
    [ "end" ; endJson ; JSONObject ] ;
    [ "summary" ; $summary ; JSONString ] ;
    [ "description" ; $description ; JSONString ] ;
    [ "location" ; $location ; JSONString ] 
  ) 

)]

# PUT Request
Insert from URL (WIP)

# Update Log File
Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:$putResult]

# Send Email
Go to Layout [T03_Lessons Admin; Animation:undefined]
Show Custom Dialog ["Send Email?"; "Notify student and tutor with email?"; buttons: {["Yes"]; ["No"]}]
If [Get(LastMessageChoice) = 1]
  Set Variable [$To; Value: formatEmailList( List( 
  T03b_lessons_STUDENTS||id_student::Student_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent1_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent2_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent3_EmailAddress_Students 
))]
  Set Variable [$CC; Value: T03j_lessons_TUTOR||id_tutor::Tutor_Company_EmailAddress]
  Send Mail (WIP)
End If

# Go to original layout
Go to Layout [original layout; Animation:undefined]
# Delete an instance of a recurring series on Google Calendar
# Mushfiq Mahmud Jun 2019

Set Error Logging (WIP)

# Make sure to go to T03_Lessons in case it is not initiated from there
// Go to Layout [Recurring Appointments; Animation:undefined]

# If this is an already cancelled appointment which was "late cancel"
If [( IsEmpty ( T03_Lessons::Start_Time ) or IsEmpty ( T03_Lessons::End_Time ) ) and T03_Lessons::Attendance = "Late Cancel"]
  Go to Layout [original layout; Animation:undefined]
  Show Custom Dialog ["Cannot cancel already cancelled lesson!"; "This lesson has already been cancelled and is marked as a late cancel."; buttons: {["OK"; commit]}]
  Halt Script
End If

# Prompt to enter Time of Cancellation if none
If [IsEmpty ( T03_Lessons::Time_Cancel_Lessons )]
  Go to Layout [original layout; Animation:undefined]
  Show Custom Dialog ["No Time of Cancellation Entered"; "Please enter a Time of Cancellation."; buttons: {["OK"; commit]; ["Cancel"]}]
  If [Get ( LastMessageChoice ) = 2]
    # If cancel was selected
    Halt Script
  End If
  # Save the entered time
  Set Field [T03_Lessons::Time_Cancel_Lessons; $enteredTimeOfCancellation]
  Set Field [T03_Lessons::Notes_Billing_Cancellations_Lessons; $enteredCancellationNotes]
End If

# Store all data and create Record in Tickets Table
Set Variable [$jsonLessonData; Value: JSONSetElement ( "{}" ;
  [ "date" ; T03_Lessons::Date; JSONString ] ;
  [ "lessonId" ; T03_Lessons::Lesson_IDpk; JSONString ] ;
  [ "start" ; T03_Lessons::Start_Time; JSONString ] ;
  [ "end" ; T03_Lessons::End_Time; JSONString ] ;
  [ "timeOfCancel" ; T03_Lessons::Time_Cancel_Lessons; JSONString ] ;
  [ "attended" ; T03_Lessons::Attendance; JSONString ] ;
  [ "familyId" ; T03_Lessons::id_family; JSONString ] ;
  [ "studentId" ; T03_Lessons::id_student; JSONString ] ;
  [ "studentName" ; T03b_lessons_STUDENTS||id_student::client_name_pk; JSONString ] ;
  [ "subjectId" ; T03_Lessons::id_subject; JSONString ] ;
  [ "tutorId" ; T03_Lessons::id_tutor; JSONString ] ;
  [ "billingNotes" ; T03_Lessons::Notes_Billing_Cancellations_Lessons; JSONString ] ;
  [ "location" ; T03_Lessons::Location; JSONString ] ;
  [ "hiddenHttpResult" ; T03_Lessons::logFile ; JSONString ]
)]

# Get instance ID
Set Variable [$instanceId; Value: T03_Lessons::event ID]

# Get tutor ID
Set Variable [$tutorId; Value: T03_Lessons::id_tutor]

# Get Access Token and Calendar ID
Perform Script  [Specified:From list; "Refresh Access Token ( tutorId )"; Parameter:$tutorId]
Set Variable [$accessToken; Value: JSONGetElement ( Get ( ScriptResult ) ; "accessToken" )]
Set Variable [$calendarId; Value: JSONGetElement ( Get ( ScriptResult ) ; "calendarId" )]

# Delete from Google Calendar
Insert from URL (WIP)
Set Variable [$deleteResult; Value: Let (
  isError = $deleteResult ≠ "" ;
  $deleteResult & ¶ & If ( isError ; "Lesson could not be deleted successfully from Calendar." ; "Lesson successfully deleted from Calendar." )
)]

# Update Log File
Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:$deleteResult]

# Send Email
Go to Layout [T03_Lessons Admin; Animation:undefined]
Show Custom Dialog ["Send Email?"; "Notify student and tutor with email?"; buttons: {["Yes"]; ["No"]}]
If [Get(LastMessageChoice) = 1]
  Set Variable [$To; Value: formatEmailList( List( 
  T03b_lessons_STUDENTS||id_student::Student_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent1_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent2_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent3_EmailAddress_Students 
))]
  Set Variable [$CC; Value: T03j_lessons_TUTOR||id_tutor::Tutor_Company_EmailAddress]
  Send Mail (WIP)
  // Send Mail (WIP)
End If

# Handle in FileMaker
If [T03_Lessons::Attendance = "Late Cancel"]
  # Vacate Start and End Time fields so that time is open for booking now
  Set Field [T03_Lessons::Start_Time; ""]
  Set Field [T03_Lessons::End_Time; ""]
  Set Field [T03_Lessons::Start End Time for Late Cancels; "start: " & JSONGetElement ( $jsonLessonData ; "start") & ¶ &
"end: " & JSONGetElement ( $jsonLessonData ; "end")]
  # Empty out the eventID field to prevent later changes to the rest of the series
  Set Field [T03_Lessons::event ID; ""]
  
  # Update Log File
  Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:$deleteResult]
Else
  # It is an on Time Cancel
  # Delete from Lessons
  Delete Record/Request [With dialog:Off]
  
  # Put all information in the cancelled table
  Go to Layout [Canceled Lessons; Animation:undefined]
  New Record/Request
  Set Field [Canceled Lessons::id_lesson; JSONGetElement ( $jsonLessonData ; "lessonId")]
  Set Field [Canceled Lessons::Date; JSONGetElement ( $jsonLessonData ; "date")]
  Set Field [Canceled Lessons::Attendance; JSONGetElement ( $jsonLessonData ; "attended")]
  Set Field [Canceled Lessons::id_family; JSONGetElement ( $jsonLessonData ; "familyId")]
  Set Field [Canceled Lessons::id_student; JSONGetElement ( $jsonLessonData ; "studentId")]
  Set Field [Canceled Lessons::id_subject; JSONGetElement ( $jsonLessonData ; "subjectId")]
  Set Field [Canceled Lessons::id_tutor; JSONGetElement ( $jsonLessonData ; "tutorId")]
  Set Field [Canceled Lessons::NotesCancel; JSONGetElement ( $jsonLessonData ; "billingNotes")]
  Set Field [Canceled Lessons::start; JSONGetElement ( $jsonLessonData ; "start")]
  Set Field [Canceled Lessons::TimeCancel; JSONGetElement ( $jsonLessonData ; "timeOfCancel")]
  Set Field [Canceled Lessons::end; JSONGetElement ( $jsonLessonData ; "end")]
  Set Field [Canceled Lessons::location; JSONGetElement ( $jsonLessonData ; "location")]
  Set Field [Canceled Lessons::event ID; $instanceId]
  
  Set Field [Canceled Lessons::log; $deleteResult & ¶ & ¶ & 

JSONGetElement ( $jsonLessonData ; "hiddenHttpResult" )]
End If


Go to Layout [original layout; Animation:undefined]

# Edit all following instances of a recurring series
# Mushfiq Mahmud June 2019

# This essentially works by splitting the series into two parts:
# 1. The first ending right before the event being modified
# 2. The other starting on the event being modified
# We have to modify the RRULE of the first half to have an UNTIL value of JUST BEFORE the start of the changed event


# STEP 1 -> Adjust the recurring series to end early
Perform Script  [Specified:From list; "End series at current lesson"; Parameter:]

# STEP:2 & 3 -> Create new recurring series; Update all following lessons in FileMaker
Perform Script  [Specified:From list; "Edit all following instances of recurring series ( eventId )"; Parameter:Let (
  indexAfterEventId = Position ( T03_Lessons::event ID ; "_" ; 1 ; 1 ) ;
  Left ( T03_Lessons::event ID ; indexAfterEventId - 1 )
)]

# Send Email
Perform Script  [Specified:From list; "Calculate recurring options from RRULE ( rrule )"; Parameter:T03_Lessons::RRULE]
Set Variable [$recurringInfoString; Value: JSONGetElement ( Get ( ScriptResult ) ; "recurringInfoString" )]

Go to Layout [T03_Lessons Admin; Animation:undefined]
Show Custom Dialog ["Send Email?"; "Notify student and tutor with email?"; buttons: {["Yes"]; ["No"]}]
If [Get(LastMessageChoice) = 1]
  Set Variable [$To; Value: formatEmailList( List( 
  T03b_lessons_STUDENTS||id_student::Student_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent1_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent2_EmailAddress_Students ;
  T03b1_lessons_students_FAMILY||Family_IDpk::Parent3_EmailAddress_Students 
))]
  Set Variable [$CC; Value: T03j_lessons_TUTOR||id_tutor::Tutor_Company_EmailAddress]
  Send Mail (WIP)
End If

Go to Layout [original layout; Animation:undefined]
# Delete all following instances of a recurring series
# Mushfiq Mahmud June 2019

Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:"Starting script: " & Get(ScriptName)]

# If this is an already cancelled appointment which was "late cancel"
If [( IsEmpty ( T03_Lessons::Start_Time ) or IsEmpty ( T03_Lessons::End_Time ) ) and T03_Lessons::Attendance = "Late Cancel"]
  Go to Layout [original layout; Animation:undefined]
  Show Custom Dialog ["Cannot cancel already cancelled lesson!"; "This lesson has already been cancelled and is marked as a late cancel."; buttons: {["OK"; commit]}]
  Halt Script
End If

# Prompt to enter Time of Cancellation for this lesson if none
If [IsEmpty ( T03_Lessons::Time_Cancel_Lessons )]
  Go to Layout [original layout; Animation:undefined]
  Show Custom Dialog ["No Time of Cancellation Entered"; "Please enter a Time of Cancellation."; buttons: {["OK"; commit]; ["Cancel"]}]
  If [Get ( LastMessageChoice ) = 2]
    # If cancel was selected
    Halt Script
  End If
  # Save the entered time
  Set Field [T03_Lessons::Time_Cancel_Lessons; $enteredTimeOfCancellation]
  Set Field [T03_Lessons::Notes_Billing_Cancellations_Lessons; $enteredCancellationNotes]
End If

# Adjust the recurring series to end early
Perform Script  [Specified:From list; "End series at current lesson"; Parameter:]

# Delete all following lessons in FileMaker
Set Error Capture [On]
// Go to Layout [Recurring Appointments; Animation:undefined]
# Get Event ID and current lesson date
Set Variable [$instanceId; Value: T03_Lessons::event ID]
Set Variable [$eventId; Value: If(Left(T03_Lessons::event ID; 1)="?" or IsEmpty(T03_Lessons::event ID);
""; // set $eventId to be empty
Let (
  indexAfterEventId = Position ( T03_Lessons::event ID ; "_" ; 1 ; 1 ) ;
  Left ( T03_Lessons::event ID ; indexAfterEventId - 1 )
))]
If [IsEmpty ( $eventId )]
  Go to Layout [original layout; Animation:undefined]
  Show Custom Dialog ["Alert!"; "Something went wrong. Event could not be deleted. Please contact your database administrator."; buttons: {["OK"; commit]}]
  Halt Script
End If
Set Variable [$date; Value: T03_Lessons::Date]

# Find events with the event ID and after the current Date (included)
Enter Find Mode [Pause:Off]
Set Field [T03_Lessons::event ID; $eventId]
Set Field [T03_Lessons::Date; "≥"  &  $date]
Perform Find []
If [Get (LastError)]
  Show Custom Dialog ["Alert!"; "Something went wrong. Event could not be deleted. Please contact your database administrator."; buttons: {["OK"; commit]}]
  Go to Layout [original layout; Animation:undefined]
  Halt Script
End If

# Delete each lesson
Set Variable [$foundLessons; Value: Get ( FoundCount )]

# If no lessons found, then stop script
If [$foundLessons ≤ 0]
  Halt Script
End If

Set Variable [$loopIndex; Value: 1]
Loop
  Exit Loop If [$loopIndex > $foundLessons]
  
  # Update cancel time and notes
  Set Field [T03_Lessons::Time_Cancel_Lessons; $enteredTimeOfCancellation]
  Set Field [T03_Lessons::Notes_Billing_Cancellations_Lessons; $enteredCancellationNotes]
  
  Set Variable [$jsonLessonData; Value: JSONSetElement ( "{}" ;
  [ "date" ; T03_Lessons::Date; JSONString ] ;
  [ "lessonId" ; T03_Lessons::Lesson_IDpk; JSONString ] ;
  [ "start" ; T03_Lessons::Start_Time; JSONString ] ;
  [ "end" ; T03_Lessons::End_Time; JSONString ] ;
  [ "timeOfCancel" ; T03_Lessons::Time_Cancel_Lessons; JSONString ] ;
  [ "attended" ; T03_Lessons::Attendance; JSONString ] ;
  [ "familyId" ; T03_Lessons::id_family; JSONString ] ;
  [ "studentId" ; T03_Lessons::id_student; JSONString ] ;
  [ "studentName" ; T03b_lessons_STUDENTS||id_student::client_name_pk; JSONString ] ;
  [ "subjectId" ; T03_Lessons::id_subject; JSONString ] ;
  [ "tutorId" ; T03_Lessons::id_tutor; JSONString ] ;
  [ "billingNotes" ; T03_Lessons::Notes_Billing_Cancellations_Lessons; JSONString ] ;
  [ "location" ; T03_Lessons::Location; JSONString ] ;
  [ "hiddenHttpResult" ; T03_Lessons::logFile ; JSONString ]
)]
  
  If [T03_Lessons::Attendance = "Late Cancel"]
    # Vacate Start and End Time fields so that time is open for booking now
    Set Field [T03_Lessons::Start_Time; ""]
    Set Field [T03_Lessons::End_Time; ""]
    Set Field [T03_Lessons::Start End Time for Late Cancels; "start: " & JSONGetElement ( $jsonLessonData ; "start") & ¶ &
"end: " & JSONGetElement ( $jsonLessonData ; "end")]
    # Empty out the eventID field to prevent later changes to the rest of the series
    Set Field [T03_Lessons::event ID; ""]
    
    # Update Log File
    Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:$deleteResult]
    
    Go to Record/Request/Page [Next; Exit after last:Off]
    
  Else
    # It is an on Time Cancel
    # Delete from Lessons
    Delete Record/Request [With dialog:Off]
    
    # Put all information in the cancelled table
    Go to Layout [Canceled Lessons; Animation:undefined]
    New Record/Request
    Set Field [Canceled Lessons::id_lesson; JSONGetElement ( $jsonLessonData ; "lessonId")]
    Set Field [Canceled Lessons::Date; JSONGetElement ( $jsonLessonData ; "date")]
    Set Field [Canceled Lessons::Attendance; JSONGetElement ( $jsonLessonData ; "attended")]
    Set Field [Canceled Lessons::id_family; JSONGetElement ( $jsonLessonData ; "familyId")]
    Set Field [Canceled Lessons::id_student; JSONGetElement ( $jsonLessonData ; "studentId")]
    Set Field [Canceled Lessons::id_subject; JSONGetElement ( $jsonLessonData ; "subjectId")]
    Set Field [Canceled Lessons::id_tutor; JSONGetElement ( $jsonLessonData ; "tutorId")]
    Set Field [Canceled Lessons::NotesCancel; JSONGetElement ( $jsonLessonData ; "billingNotes")]
    Set Field [Canceled Lessons::start; JSONGetElement ( $jsonLessonData ; "start")]
    Set Field [Canceled Lessons::TimeCancel; JSONGetElement ( $jsonLessonData ; "timeOfCancel")]
    Set Field [Canceled Lessons::end; JSONGetElement ( $jsonLessonData ; "end")]
    Set Field [Canceled Lessons::location; JSONGetElement ( $jsonLessonData ; "location")]
    Set Field [Canceled Lessons::event ID; $instanceId]
    
    Set Field [Canceled Lessons::log; $deleteResult & ¶ & ¶ & 

JSONGetElement ( $jsonLessonData ; "hiddenHttpResult" )]
  End If
  
  Go to Layout [T03_Lessons Admin; Animation:undefined]
  # Go to next record
  Set Variable [$loopIndex; Value: $loopIndex + 1]
End Loop

// # Return found set with existing records
// Enter Find Mode [Pause:Off]
// Set Field [T03_Lessons::event ID; $eventId]
// Perform Find []
Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:"Ended script: " & Get(ScriptName)]
Show All Records

# Go to Orignal Layout
Go to Layout [original layout; Animation:undefined]

# Modifying the following instances in a recurring series
# Mushfiq Mahmud June 2019
# This script changes the the UNTIL value for original series to end JUST BEFORE the currently selected lesson start DATE

Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:"Starting script: " & Get(ScriptName)]
# Get the event ID
Set Variable [$instanceId; Value: T03_Lessons::event ID]
Set Variable [$eventId; Value: Left ( $instanceId ; Position ( $instanceId ; "_" ; 1 ; 1 ) - 1 )]
If [IsEmpty ( $eventId )]
  Go to Layout [original layout; Animation:undefined]
  Show Custom Dialog ["Missing Event ID"; "The event ID for this lesson is missing. Please contact Database administrator."; buttons: {["OK"; commit]; ["Cancel"]}]
End If

# Get Original Post Body Data
Set Variable [$data; Value: JSONGetElement ( T03_Lessons::originalRecurringEventData ; "originalData" )]
If [IsEmpty ( $data ) or Left($data; 1) = "?"]
  Go to Layout [original layout; Animation:undefined]
  Show Custom Dialog ["Recurring lesson could not be deleted."; "The recurring lesson could not be deleted. Please contact database administrator with the following error message." &¶&¶&

"originalRecurringEventData for the original lesson could not be retrieved at script: " & Get(ScriptName) & "."; buttons: {["OK"; commit]; ["Cancel"]}]
  Halt Script
End If

# Get the RRULE
Set Variable [$rrule; Value: JSONGetElement ( $data ; "recurrence[0]" )]

# Find out DST Offset for start datetime
Set Variable [$startTime; Value: T03_Lessons::Start_Time]
Set Variable [$date; Value: T03_Lessons::Date]
Set Variable [$startTimestamp; Value: Let (

  // Variables
  [
    hour = Hour ( GetAsTime ( $startTime ) ) ;
    minute = Minute ( GetAsTime ( $startTime ) ) ;
    date = GetAsDate ( $date ) ;
    dateTime = date & " " & "12:00:00 am"
  ] ;

  // Calculation
  GetAsTimestamp ( dateTime )

)]

# Find UTC Timestamp
Set Variable [$dstOffset; Value: FindDSTOffset ( $startTimestamp )]
Set Variable [$offsettedTimestamp; Value: /*
 * Notes:
 * --$dstOffset is negative in the US. Therefore, it needs to be subtracted in order to be added
 * --multiply by 3600 to convert to hours
 * --subtract a second to not include the start time. We want the recurring series to end just before the start time
 */

$startTimestamp - GetAsNumber ( $dstOffset ) * 3600 - 1]

# Calculate UNTIL time for modifying the RRULE
Set Variable [$untilDate; Value: Let (

  // Variables
  [
    ts = $offsettedTimestamp ;
    year = Right ( "0000" & Year ( ts ) ; 4 ) ;
    month = Right ( "00" & Month ( ts ) ; 2 ) ;
    day = Right ( "00" & Day ( ts ) ; 2 ) ;
    hour = Right ( "00" & Hour ( ts ) ; 2 ) ;
    minute = Right ( "00" & Minute ( ts ) ; 2 ) ;
    second = Right ( "00" & Seconds ( ts ) ; 2 )
  ] ;

  // Calculation
  year & month & day & "T" & hour & minute & second & "Z" 

)]

# Modify the RRULE to end at the start time
Set Variable [$newRrule; Value: Let (
  
  // Variables
  [
    positionOfUntil = Position ( $rrule ; ";UNTIL=" ; 1 ; 1 ) ; // index of "UNTIL" if it exists
    positionOfCount = Position ( $rrule ; ";COUNT=" ; 1 ; 1 ) ; // index of "COUNT" if it exists

    hasUntil = positionOfUntil > 0 ; // True if "UNTIL" exists
    hasCount = positionOfCount > 0 ; // True if "COUNT" exists

    modifiedRrule = Case ( 
      hasUntil ; Left ( $rrule ; positionOfUntil ) ;
      hasCount ; Left ( $rrule ; positionOfCount ) ;
      $rrule
    )
  ] ;

  // Calculation
  modifiedRrule & "UNTIL=" & $untilDate

)]

# Update the request body to include the new RRULE
Set Variable [$data; Value: JSONSetElement ( $data ; "recurrence[0]" ; $newRrule ; JSONString )]
Set Variable [$data; Value: Quote ( $data )]

# Get tutor ID
Set Variable [$tutorId; Value: T03_Lessons::id_tutor]
# Refresh the tutor's access token
Perform Script  [Specified:From list; "Refresh Access Token ( tutorId )"; Parameter:$tutorId]
Set Variable [$accessToken; Value: JSONGetElement ( Get ( ScriptResult ) ; "accessToken" )]
Set Variable [$calendarId; Value: JSONGetElement ( Get ( ScriptResult ) ; "calendarId" )]

# Get Recurring Instances
Perform Script  [Specified:From list; "Get Recurring Instances ( calendarId, eventId, accessToken )"; Parameter:JSONSetElement("{}";
["calendarId"; $calendarId; JSONString];
["eventId"; $eventId; JSONString];
["accessToken"; $accessToken; JSONString]
)]
Set Variable [$datesAndInstanceIdList; Value: Get ( ScriptResult )]
# Check if currently selected lesson is the start of the series
Set Variable [$isStartOfSeries; Value: Let([
  firstItemDate = JSONGetElement($datesAndInstanceIdList; "items[0].date");
  firstItemInstanceId = JSONGetElement($datesAndInstanceIdList; "items[0].instanceId")
];
firstItemDate = $date or firstItemInstanceId = $instanceId
)]

If [$isStartOfSeries]
  # Delete whole series
  Insert from URL (WIP)
  Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:"The whole recurring series was deleted."]
Else
  # PUT request to update original recurring series to end
  Insert from URL (WIP)
  Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:"All following lessons in the recurring series were deleted."]
End If

# Update Log File
Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:$curlResult]
Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:"Ended script: " & Get(ScriptName)]
# Modifying the following instances in a recurring series
# Part II: Creating new series to start at the currently selected lesson start time
# Mushfiq Mahmud June 2019

# STEP:2 -> Create new recurring series

Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:"Starting script: " & Get(ScriptName)]
# Get event ID from script parameter
Set Variable [$oldEventId; Value: Get ( ScriptParameter )]

# Get last End DateTime
Set Variable [$lastEndDatetime; Value: Let([
  lastEndDatetime = JSONGetElement(T03_Lessons::originalRecurringEventData; "lastEndDatetime");
  lastEndDate = GetAsDate(convertDatetimeToTimestamp(lastEndDatetime));
  newUntilDate = convertToUTCTimestamp(lastEndDate; Time(23; 59; 59));
  newUntilDateFormatted = Substitute(newUntilDate; ["-" ; ""]; [":" ; ""])
]; newUntilDateFormatted)

/*Let([
  untilDate = JSONGetElement ( T03_Lessons::originalRecurringEventData ; "lastEndDatetime" ) ;
  untilDateWithoutDashes = Substitute ( untilDate ; "-" ; "" ) ; 
  untilDateWithoutColons = Substitute ( untilDateWithoutDashes ; ":" ; "" )
]; untilDateWithoutColons)*/]

# Calculate new RRULE
Perform Script  [Specified:From list; "Calculate RRULE"; Parameter:]
# if the Calculate RRULE script did not return anything, then there is a problem. Create error log and halt script. (JRay)
If [IsEmpty ( Get (ScriptResult ) )]
  Perform Script  [Specified:From list; "Create Error Log - Modular"; Parameter:Get (ScriptName) & ¶ & 
"RRULE could not be created for Lesson #" & T03_Lessons::Lesson_IDpk]
  Go to Layout [original layout; Animation:undefined]
  Halt Script
End If
Set Variable [$rrule; Value: Get ( ScriptResult )]
Set Variable [$rrule; Value: Let (
  
  // Variables
  [
    positionOfUntil = Position ( $rrule ; ";UNTIL=" ; 1 ; 1 ) ; // index of "UNTIL" if it exists
    positionOfCount = Position ( $rrule ; ";COUNT=" ; 1 ; 1 ) ; // index of "COUNT" if it exists

    hasUntil = positionOfUntil > 0 ; // True if "UNTIL" exists
    hasCount = positionOfCount > 0 ; // True if "COUNT" exists

    modifiedRrule = Case ( 
      hasUntil ; Left ( $rrule ; positionOfUntil ) ;
      hasCount ; Left ( $rrule ; positionOfCount ) ;
      $rrule
    )
  ] ;

  // Calculation
  "RRULE:" & modifiedRrule & "UNTIL=" & $lastEndDatetime

)]
Set Field [T03_Lessons::RRULE; $rrule]
Set Field [T03_Lessons::RecurringUntil; Let([
lastEndDatetime = JSONGetElement(T03_Lessons::originalRecurringEventData ;"lastEndDatetime");
_list = Substitute(Left(lastEndDateTime; 10); "-"; "¶");
_year = GetValue(_list; 1);
_month = GetValue(_list; 2);
_date = GetValue(_list; 3)
];
Date(_month; _date; _year)
)]
Set Field [T03_Lessons::RecurringEndingChoice; "Until"]

# Date, Start and End
Set Variable [$startTime; Value: formatTime ( T03_Lessons::Start_Time ; "HH:MM:SS" )]
Set Variable [$endTime; Value: formatTime ( T03_Lessons::End_Time ; "HH:MM:SS" )]
Set Variable [$timeZone; Value: "America/New_York"]
Set Variable [$date; Value: formatDate ( T03_Lessons::Date ; "YYYY-MM-DD" )]
Set Variable [$startDateTime; Value: $date & "T" & $startTime // startDateTime]
Set Variable [$endDateTime; Value: $date & "T" & $endTime // endDateTime]

# Get tutor ID
Set Variable [$tutorId; Value: T03_Lessons::id_tutor]

# Create new data variable
Set Variable [$data; Value: Let ( 
  [
    startJson = JSONSetElement ( "{}" ; 
      [ "dateTime" ; $startDateTime ; JSONString ] ;
      [ "timeZone" ; $timeZone ; JSONString ] 
    ) ;
    endJson = JSONSetElement ( "{}" ; 
      [ "dateTime" ; $endDateTime ; JSONString ] ;
      [ "timeZone" ; $timeZone ; JSONString ] 
    ) 
  ] ;

  JSONSetElement ( "{}" ; 
    [ "start" ; startJson ; JSONObject ] ;
    [ "end" ; endJson ; JSONObject ] ;
    [ "summary" ; T03_Lessons::gcal title ; JSONString ] ;
    [ "description" ; T03_Lessons::gcal description ; JSONString ] ;
    [ "location" ; T03_Lessons::Location ; JSONString ] ;
    [ "recurrence[0]" ; $rrule ; JSONString ]
  ) 

)]

# Refresh the tutor's access token
Perform Script  [Specified:From list; "Refresh Access Token ( tutorId )"; Parameter:$tutorId]
Set Variable [$accessToken; Value: JSONGetElement ( Get ( ScriptResult ) ; "accessToken" )]
Set Variable [$calendarId; Value: JSONGetElement ( Get ( ScriptResult ) ; "calendarId" )]

# POST request to create new recurring series
Insert from URL (WIP)
Set Variable [$eventId; Value: JSONGetElement ( $postResult ; "id")]

# Update log file in T03_LESSONS
Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:$postResult]

# Get the instances for the new series
Perform Script  [Specified:From list; "Get Recurring Instances ( calendarId, eventId, accessToken )"; Parameter:JSONSetElement ( "{}" ; 
  [ "calendarId" ; $calendarId ; JSONString ] ;
  [ "eventId" ; $eventId ; JSONString ] ;
  [ "accessToken" ; $accessToken ; JSONString ]
)]
Set Field [T03_Lessons::event ID; JSONGetElement ( Get ( ScriptResult ) ; "items[0].instanceId" )]
Set Field [T03_Lessons::eventIDDump; List(T03_Lessons::eventIDDump; JSONGetElement ( Get ( ScriptResult ) ; "items[0].instanceId" ))]

# Get all following new instanceIds and add the old event ID to be passed into the next script
Set Variable [$newInstaceIdsAndDatesListWithOldEventId; Value: JSONSetElement ( Get ( ScriptResult ) ; "oldEventId" ; $oldEventId ; JSONString )]

# Store the original recurring event data
Set Field [T03_Lessons::originalRecurringEventData; Substitute(JSONFormatElements(JSONSetElement ( "{}" ; 
  ["originalData"; $data; JSONObject];
  ["lastEndDatetime"; JSONGetElement($newInstaceIdsAndDatesListWithOldEventId; "lastEndDatetime"); JSONString]
)); "	"; "  ")]

# Update Log File
Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:$postResult]
Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:$newInstaceIdsAndDatesListWithOldEventId]

# STEP:3 -> Edit all the following records in FM
Perform Script  [Specified:From list; "Change all following event details in FM"; Parameter:$newInstaceIdsAndDatesListWithOldEventId]

# Go to original Layout
Go to Layout [original layout; Animation:undefined]

Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:"Ended script: " & Get(ScriptName)]
# Modifying the following instances in a recurring series
# Part III: Change records in FM
# Mushfiq Mahmud June 2019

Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:"Starting script: " & Get(ScriptName)]

# STEP:3 -> Update all following lessons in FileMaker
Set Error Capture [On]

# Get new RRULE
Set Variable [$rrule; Value: T03_Lessons::RRULE]

# Get script Parameter
Set Variable [$newInstanceIdsAndDatesListWithOldEventId; Value: Get ( ScriptParameter )]

# Get the old event ID for finding purposes
Set Variable [$oldEventId; Value: JSONGetElement ( $newInstanceIdsAndDatesListWithOldEventId ; "oldEventId" )]

# Get count of dates
Set Variable [$recurringEventCount; Value: ValueCount ( JSONListKeys ( $newInstanceIdsAndDatesListWithOldEventId; "items") )]

# Check if only one event was affected, in which case there is no need to run this script.
If [$recurringEventCount ≤ 1]
  Exit Script [undefined]
End If

# Get the second from the list since the first one is already changed in the last script
Set Variable [$findStartDate; Value: JSONGetElement ( $newInstanceIdsAndDatesListWithOldEventId ; "items[1].date" )]

# Calculate new Duration
Set Field [T03_Lessons::Duration; (T03_Lessons::End_Time - T03_Lessons::Start_Time) / 3600]

# Since we are still on the affected lesson, get all lesson details from here
Set Variable [$studentId; Value: T03_Lessons::id_student]
Set Variable [$subjectId; Value: T03_Lessons::id_subject]
Set Variable [$tutorId; Value: T03_Lessons::id_tutor]
Set Variable [$startTime; Value: T03_Lessons::Start_Time]
Set Variable [$endTime; Value: T03_Lessons::End_Time]
Set Variable [$location; Value: T03_Lessons::Location]
Set Variable [$rrule; Value: T03_Lessons::RRULE]
Set Variable [$endingChoice; Value: T03_Lessons::RecurringEndingChoice]
Set Variable [$untilDate; Value: T03_Lessons::RecurringUntil]
Set Variable [$originalData; Value: T03_Lessons::originalRecurringEventData]

# Find events with the old event ID and after the find Date (included)
Enter Find Mode [Pause:Off]
Set Field [T03_Lessons::event ID; $oldEventId]
Set Field [T03_Lessons::Date; $findStartDate & "..."]
Perform Find []

If [Get(LastError) or Get(FoundCount) < 1]
  Show Custom Dialog ["Error in script: " & Get(ScriptName); "An error occurred while attempting to delete this recurring event. The recurring event could not be deleted. Please contact your database administrator to troubleshoot."; buttons: {["OK"; commit]}]
  Close Window (WIP)
  Halt Script
End If

Set Variable [$foundLessons; Value: Get ( FoundCount )]
Set Variable [$loopIndex; Value: 1]
Loop
  Exit Loop If [$loopIndex > $foundLessons]
  
  Set Field [T03_Lessons::id_student; $studentId]
  Set Field [T03_Lessons::id_subject; $subjectId]
  Set Field [T03_Lessons::id_tutor; $tutorId]
  Set Field [T03_Lessons::Start_Time; $startTime]
  Set Field [T03_Lessons::End_Time; $endTime]
  Set Field [T03_Lessons::Location; $location]
  Set Field [T03_Lessons::RRULE; $rrule]
  Set Field [T03_Lessons::RecurringEndingChoice; $endingChoice]
  Set Field [T03_Lessons::RecurringUntil; $untilDate]
  Set Field [T03_Lessons::originalRecurringEventData; $originalData]
  Set Field [T03_Lessons::event ID; // NOTE: no need to add or subtract 1 to $loopIndex, since we want the second element from the array and onwards
JSONGetElement ( $newInstanceIdsAndDatesListWithOldEventId ; "items[" & $loopIndex & "].instanceId" )]
  Set Field [T03_Lessons::eventIDDump; List(T03_Lessons::eventIDDump; 
JSONGetElement ( $newInstanceIdsAndDatesListWithOldEventId ; "items[" & $loopIndex & "].instanceId" ))]
  
  Go to Record/Request/Page [Next; Exit after last:Off]
  Set Variable [$loopIndex; Value: $loopIndex + 1]
End Loop

Enter Find Mode [Pause:Off]
Set Field [T03_Lessons::event ID; Let (
  [
    instanceId = JSONGetElement ( $newInstanceIdsAndDatesListWithOldEventId ; "items[0].instanceId" ) ;
    indexAfterInstanceId = Position ( instanceId ; "_" ; 1 ; 1 )
  ] ;
  Left ( instanceId ; indexAfterInstanceId - 1 )
)]
Perform Find []
Sort Records by Field (WIP)

# Go to Orignal Layout
Go to Layout [original layout; Animation:undefined]

Perform Script  [Specified:From list; "Update Log File in T03_Lessons ( msg )"; Parameter:"Ended script: " & Get(ScriptName)]
# This script runs when the repeating conditions are changed for an existing recurring series (WORK IN PROGRESS)
# Mushfiq July 2019

Go to Layout [Recurring Appointments; Animation:undefined]

# Calculate new RRULE
Perform Script  [Specified:From list; "Calculate RRULE"; Parameter:]

# Get the event ID
Set Variable [$eventId; Value: Let (
  indexAfterEventId = Position ( T03_Lessons::event ID ; "_" ; 1 ; 1 ) ;
  Left ( T03_Lessons::event ID ; indexAfterEventId - 1 )
)]

Go to Layout [original layout; Animation:undefined]

#  .....
# This modular script that is used for creating error logs and sending an email to the database administrator. Whatever is passed as the script parameter will the text in the error log.

Set Error Capture [On]

# Get Script Parameter
Set Variable [$scriptParam; Value: Get ( ScriptParameter )]
# If the script parameter is empty, then do not create an error log.
# Having an empty script parameter should never happen.
If [not IsEmpty ( $scriptParam )]
  # Error Log
  Go to Layout [Error_Logs; Animation:undefined]
  If [not Get ( LastError )]
    New Record/Request
    Set Field [Error_Logs::Error_Code; 0]
    Set Field [Error_Logs::Script_Name; GetValue ( Get ( ScriptName ) ; 1 )]
    Set Field [Error_Logs::Error_Log_Text; GetValue ( Get ( ScriptName ) ; 2 ) &¶& $scriptParam]
    Commit Records/Requests [With dialog:Off]
  End If
  Send Mail (WIP)
  Halt Script
End If

